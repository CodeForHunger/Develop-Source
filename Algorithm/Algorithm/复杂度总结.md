<h1 align="center">复杂度总结</h1>

[toc]

## 1 时间频度

一个算法中的语句执行次数成为频度或者时间频度。记为：$T(n)$

## 2 时间复杂度

算法中基本操作重复执行的次数是问题规模$n$的某个函数，用$T(n)$表示，若有某个辅助函数$f(n)$，使得当n趋近于无穷大时，$T(n)/f(n)$的极限值为不等于零的常数，则称$f(n)$是$T(n)$的同数量级函数。记作$T(n)=Ｏ(f(n))$，称$Ｏ(f(n))$ 为算法的渐进时间复杂度，简称时间复杂度。

$T (n) = Ο(f(n))$ 表示存在一个常数$C$，使得在当n趋于正无穷时总有 $T(n) ≤ C * f(n)$。简单来说，就是$T(n)$在n趋于正无穷时最大也就跟$f(n)$差不多大。也就是说当$n$趋于正无穷时$T(n)$的上界是$C * f(n)$。其虽然对$f(n)$没有规定，但是一般都是取尽可能简单的函数。

例如：
    
$$O(2n^2+n +1) = O(3n^2+n+3) = O(7n^2 + n) = O(n^2)$$
    
一般都是用$O(n^2)$表示。

渐近记号（Asymptotic Notation）通常有 $O$、 $Θ$ 和 $Ω$ 记号法。$Θ$ 记号渐进地给出了一个函数的上界和下界，当只有渐近上界时使用 $O$ 记号，当只有渐近下界时使用 $Ω$ 记号。尽管技术上 $Θ$ 记号较为准确，但通常仍然使用 $O$ 记号表示。

常见复杂度：“大O符号表示法并不是用于来真实代表算法的执行时间的，它是用来表示代码执行时间的增长变化趋势的”。

- 常数阶O(1)
- 线性阶O(n)
- 对数阶O(logN)
- 线性对数阶O(nlogN)
- 平方阶O(n²)
- 立方阶O(n³)
- K次方阶O(n^k)
- 指数阶(2^n)

​    解释：

* 线性复杂度 O(n) 表示每个元素都要被处理一次。
* 平方复杂度 O($n^2$) 表示每个元素都要被处理 n 次。
  
| **Notation**    | **Intuition**  | **Informal Definition**  |
| --------- | ----------- | ------------- |
| $f(n) \in O(g(n))$ | f is bounded above by g asymptotically | $ \vert f(n) \vert \leq g(n) \cdot k$ |
| $f(n) \in \Omega(g(n))$ | Two definitions : Number theory:f is not dominated by g asymptoticallyComplexity theory:f is bounded below by g asymptotically | $f(n) \geq g(n) \cdot k$ |
| $f(n) \in \Theta(g(n))$ | f is bounded both above and below by g asymptotically   | $g(n) \cdot k_{1} \leq f(n) \leq g(n) \cdot k_{2}$ |

例如：

    * T(n) = O(n3) 等同于 T(n) ∈ O(n3)
    * T(n) = Θ(n3) 等同于 T(n) ∈ Θ(n3).

| **复杂度**          | **标记符号**      | **描述**               |
| ------------------- | ----------------- | ------------------- |
| 常量（Constant） | $O(1)$  | 操作的数量为常数，与输入的数据的规模无关。n = 1,000,000 -> 1-2 operations |
| 对数（Logarithmic） | $O(log_2 n)$         | 操作的数量与输入数据的规模 n 的比例是 $log_2(n)$。n = 1,000,000 -> 30 operations |
| 线性（Linear）      | $O(n)$              | 操作的数量与输入数据的规模 n 成正比。n = 10,000 -> 5000 operations |
| 平方（Quadratic）   | $O(n^2)$             | 操作的数量与输入数据的规模 n 的比例为二次平方。n = 500 -> 250,000 operations |
| 立方（Cubic）       | $O(n^3)$             | 操作的数量与输入数据的规模 n 的比例为三次方。n = 200 -> 8,000,000 operations |
| 指数（Exponential） | $O(2^n)$ $O(k^n)$ $O(n!)$ | 指数级的操作，快速的增长。n = 20 -> 1048576 operations |

**注1**：快速的数学回忆，$log_ab = y$ 其实就是 $a^y = b$。所以，$log_24 = 2$，因为 $2^2 = 4$。同样 $log_2 8 = 3$，因为 $2^3 = 8$。我们说，$log_2n$ 的增长速度要慢于 n，因为当 n = 8 时，$log_2n = 3$。
    
**注2**：通常将以 10 为底的对数叫做常用对数。为了简便，N 的常用对数 $log_{10} N$ 简写做 $lg N$，例如 $log_{10} 5$ 记做 $lg 5$。
    
**注3**：通常将以无理数 e 为底的对数叫做自然对数。为了方便，N 的自然对数 $log_e N$ 简写做 $ln N$，例如 $log_e 3$ 记做 $ln 3$。
    
**注4**：在算法导论中，采用记号 $lg n = log_2 n$ ，也就是以 2 为底的对数。改变一个对数的底只是把对数的值改变了一个常数倍，所以当不在意这些常数因子时，我们将经常采用 "$lg n$"记号，就像使用 $O$ 记号一样。计算机工作者常常认为对数的底取 2 最自然，因为很多算法和数据结构都涉及到对问题进行二分。

通常时间复杂度与运行时间的比例关系：
    
| **复杂度**   | **10**  | **20** | **50**   | **100** | **1000** | **10000** | **100000** |
| ------------ | ------- | ------ | -------- | ------- | -------- | --------- | ---------- |
| $O(1)$         | <1s     | <1s    | <1s      | <1s     | <1s      | <1s       | <1s        |
| $O(log_2(n))$   | <1s     | <1s    | <1s      | <1s     | <1s      | <1s       | <1s        |
| $O(n)$         | <1s     | <1s    | <1s      | <1s     | <1s      | <1s       | <1s        |
| $O(n*log_2(n))$ | <1s     | <1s    | <1s      | <1s     | <1s      | <1s       | <1s        |
| $O(n^2)$        | <1s     | <1s    | <1s      | <1s     | <1s      | 2s        | 3-4 min    |
| $O(n^3)$        | <1s     | <1s    | <1s      | <1s     | 20s      | 5 hours   | 231 days   |
| $O(2^n)$        | <1s     | <1s    | 260 days | hangs   | hangs    | hangs     | hangs      |
| $O(n!)$        | <1s     | hangs  | hangs    | hangs   | hangs    | hangs     | hangs      |
| $O(n^n)$        | 3-4 min | hangs  | hangs    | hangs   | hangs    | hangs     | hangs      |

### $O(1)$--常数阶

``` java
Temp = i; 
i = j; 
j = temp; 
```

以上三条单个语句的频度均为1，该程序段的执行时间是一个与问题规模n无关的常数。算法的时间复杂度为常数阶，记作T(n)=O(1)。注意：如果算法的执行时间不随着问题规模n的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此类算法的时间复杂度是O(1)。

### $O(n)$--线性阶

```java
a = 0;
b = 1;                      ①
for (i = 1; i <= n; i++)        ②
{  
    s=a+b;　　　　         ③
    b=a;　　　　　         ④  
    a=s;　　　　　         ⑤
}
```

​	解： 语句1的频度：2,       
    		 语句2的频度： n,       
    		 语句3的频度： n-1,       
    	     语句4的频度：n-1,   
   		  语句5的频度：n-1,                                 
   		  $T(n)=2+n+3(n-1)=4n-1=O(n)$.

### $O(logN)$--对数阶

```java
int i = 1;
while(i < n) {
    i = i * 2;
}
1234
```

可以看到每次循环的时候 i 都会乘2，那么总共循环的次数就是log2n，因此这个代码的时间复杂度为O(logn)。这儿有个问题，为什么明明应该是O(log2n）,却要写成O(logn)呢？其实这里的底数对于研究程序运行效率不重要，写代码时要考虑的是数据规模n对程序运行效率的影响，常数部分则忽略，同样的，如果不同时间复杂度的倍数关系为常数，那也可以近似认为两者为同一量级的时间复杂度。

### **$O(log_2n)$--对数阶**

```java
i=1;            ①
while (i <= n)
   i = i * 2;       ②
```

解： 语句1的频度是1, 
    设语句2的频度是f(n),   则：$2^{f(n)}<=n;f(n)<=log_2n$    
    取最大值$f(n)=log_2n$,
    $T(n)=O(log_2n)$

### $O(nlogN)$--线性对数阶

```java
for(m = 1; m < n; m++) {
    i = 1;
    while(i < n) {
        i = i * 2;
    }
}
```

线性对数阶O(nlogN) 其实非常容易理解，将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN)。

### **$O(n^2)$--平方阶**

```java
// 交换i和j的内容
sum = 0；                  （一次）
for(i = 1; i <= n; i++)       （n+1次）
for(j = 1; j <= n; j++)       （n2次）
sum++；                 （n2次）
```

​	解：因为$Θ(2n^2+n+1)=n^2$（Θ即：去低阶项，去掉常数项，去掉高阶项的常参得到），所以$T(n)= =O(n^2)$；

```java
   for (i = 1; i < n; i++)
    { 
        y = y + 1;         ①   
        for (j = 0; j <= (2 * n); j++)    
           x++;         ②      
    }  
```

​	解： 语句1的频度是n-1
    语句2的频度是$(n-1)*(2n+1)=2n^2-n-1$
    $f(n)=2n^2-n-1+(n-1)=2n^2-2$；

    又$Θ(2n^2-2)=n^2$
    该程序的时间复杂度$T(n)=O(n^2)$.  

　　一般情况下，对步进循环语句只需考虑循环体中语句的执行次数，忽略该语句中步长加1、终值判别、控制转移等成分，当有若干个循环语句时，算法的时间复杂度是由嵌套层数最多的循环语句中最内层语句的频度f(n)决定的。 

### **$O(n^3)$--立方阶**

```java
 for(i = 0; i < n; i++) {  
       for(j = 0; j < i; j++)  
       {
          for(k = 0; k<j; k++)
             x = x + 2;  
       }
  }
```

解：当i=m, j=k的时候,内层循环的次数为k当i=m时, j 可以取 $0,1,...,m-1$ , 所以这里最内循环共进行了$0+1+...+m-1=(m-1)m/2$次所以,i从0取到n, 则循环共进行了: $0+(1-1)*1/2+...+(n-1)n/2=n(n+1)(n-1)/6$所以时间复杂度为$O(n^3)$.

## 3 空间复杂度

### 定义：空间复杂度：就是执行程序需要的存储空间的大小，执行程序需要的存储空间越小就越好。

### $O(1)$

如果算法执行所需要的临时空间不随着某个变量n的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1)。

```java
int i = 1;
int j = 2;
++i;
j++;
int m = i + j;
12345
```

代码中的 i、j、m 所分配的空间都不随着处理数据量变化，因此它的空间复杂度 S(n) = O(1)。

### $O(n)$

```java
int[] m = new int[n]
for(i = 1; i <= n; ++i) {
   j = i;
   j++;
}
12345
```

这段代码中，第一行new了一个数组出来，这个数据占用的大小为n，后面虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即 S(n) = O(n)。



## 参考：

* https://blog.csdn.net/zolalad/article/details/11848739
* https://www.cnblogs.com/gaochundong/p/complexity_of_algorithms.html
* https://mp.weixin.qq.com/s/1crt5oevFWhhPRz7y4FDng

