<h1 align="center">二进制的奥秘：用逻辑运算实现加减法</h1>

我又要来说二进制了，因为二进制和计算机有着很深的联系。人类为什么会发明十进制的计数？很大可能是人类有10根手指，如果是海豚，也许它会发明二进制：)

二进制和十进制没有很大的区别，都是用来计数的，但二进制还可以用来做逻辑运算，而逻辑运算才是计算机最擅长做的事情。我们在学校里学习计算机组成原理时，就知道有很多电子元件：与门，或门，非门，异或门等等，这些逻辑门控制高低电平，从而实现逻辑运算。

再说到算术运算：加减乘除，计算机并不天生就会，它们是通过逻辑运算来实现的，这一篇，我打算用逻辑运算来实现算术运算，为简单起见，先从加减开始。

## 加法

回想一下加法是怎么做：

```text
    168
    257
-------------
    425
```

- 先取个位数的8，7相加，此时产生一个和5，以及一个进位1
- 再取十位数的6，5加相，这一次要把上面的进位考虑进来，得到和是2，进位1
- 最后百位数的1，2加相，上一步进位为1，所以加起来得到4，最终结果就是425

二进制的加也是一样的：对应的每一位相加，得到和，进位两个值：

```text
‭   1 1 0 1
‭   1 0 0 1‬
---------------------
‬ 1 0 1 1 0
```

我们只取1位来看，和只有4种情况：

```text
      | 0  1
    ----------
    0 | 0  1
    1 | 1  0
```

- 当上下两位都为0时，和为0。
- 当上下两位有一个为1时，和为1。
- 当上下两位都为1时，和为0。

这实际上就是`异或`的结果

再看看进位的情况：

```text
      | 0  1
    ----------
    0 | 0  0
    1 | 0  1
```

- 当上下两位都为0时，进位为0。
- 当上下两位有一个为1时，进位还是为0。
- 当上下两位为1时，进位为1。

这就是`与`的结果。

分析下来有一点成果了，这一次我们使用Go来写，先定义一个Bit的类型，代表1位：

```go
// Bit 代表1位
type Bit = byte;
```

然后写一个函数，模拟1位二进制相加：

```go
// HalfAdder 半加器，输入两个位，返回和，进位
func HalfAdder(a Bit, b Bit) (s Bit, c Bit) {
    s = a ^ b
    c = a & b
    return s, c
}
```

看起来很简单，s代表和，是两个位异或的结果；c代表进位，是两个位与的结果。

多个二进制位相加，要考虑前面的进位，即需要3个位相加：

```go
// FullAdder 全加器，输入两个位和前一个进位，返回和，进位
func FullAdder(a Bit, b Bit, c Bit) (Bit, Bit) {
    var s, c2, c3, c4 Bit
    // a, b相加，得到和(s), 进位(c2)
    s, c2 = HalfAdder(a, b)
    // s, c相加，得到s, c3
    s, c3 =  HalfAdder(s, c)
    // 最终的进位是c2或c3，这是一种优化方式：因为s2和s3不会同时为1
    c4 = c2 | c3
    return s, c4
}
```

有了1位全加器之后，就可以实现多位全加器了，比如下面的8位全加器：

```go
// Bit8 8位数字
type Bit8 [8]Bit

// Bit8FullAdder 8位全加器，输入两个8位数字，返回8位数字，和一个进位(也就是溢出)
func Bit8FullAdder(a Bit8, b Bit8, c Bit) (Bit8, Bit) {
    var s Bit8;
    s[0], c = FullAdder(a[0], b[0], c)
    s[1], c = FullAdder(a[1], b[1], c)
    s[2], c = FullAdder(a[2], b[2], c)
    s[3], c = FullAdder(a[3], b[3], c)
    s[4], c = FullAdder(a[4], b[4], c)
    s[5], c = FullAdder(a[5], b[5], c)
    s[6], c = FullAdder(a[6], b[6], c)
    s[7], c = FullAdder(a[7], b[7], c)
    return s, c
}
```

为了验证结果 ，我们写一个辅助函数，这个不算在实现之内，所以可以随意写：

```go
func add(a byte, b byte) byte {
    // 把byte转化为Bit8
    var a8, b8 Bit8;
    for i := 0; i < 8; i++ {
        a8[i] = (a >> i) & 1
        b8[i] = (b >> i) & 1
    }
    // 相加
    s8, _ := Bit8FullAdder(a8, b8, 0)
    // 再把结果转化为byte
    var s byte = 0;
    for i := 0; i < 8; i++ {
        s |= s8[i] << i
    }
    return s
}

func main() {
    s := add(12, 25)
    fmt.Printf("%d\n", s)    // 37
}
```

恭喜，你已经用程序实现了一个加法器。

## 减法

减法可以转换成加一个负值，比如12 - 8，转换成12 + (-8)，这两个是等价的。这就引出另一个问题，计算机怎么表示负数的？

按正常思路，可以用最高位代表符号，0代表正，1代表负，比如一个8位二进制：0000 0001是1，1000 0001是-1；这看起来很自然。但是你马上会发现：0000 0000和1000 0000这两个值出现矛盾了，从字面上理解这两个都是0，应该是相等的。但从内存上看这两个字节又是不相等的。

计算机先驱们用另一种方式存储负数，首先对于一个整型，我们要先明确它是有符号的还是无符号的，同样的存储，有符号和无符号代表的数值可能是不一样的，以一个8位数为例：

```text
二进制  00000000 00000001 00000010...01111111 10000000 10000001...11111110 11111111
无符号         0        1        2........127      128      129........254      255
有符号         0        1        2........127     -128     -127.........-2       -1
```

有符号数到达127之后，再往后是-128，后面是-127,-126...一直到-1，这样8位有符号数的范围就是：-128~127。

虽然从二进制看一直在涨，但到10000000以后，其表示的含义却是从负数的最大值往下减。10000000，10000001这些二进制被称为负数的补码形式，所以计算机是用负数的补码来表示负数的。

负数的补码和对应的正数有一个奇妙的运算关系：

- 对一个正数取反，再加1，会得到其负数的补码。
- 对一个负数的补码取反，再加1，会得到其正数。

举两个例子（以8位有符号数为例）：

- 一个正数2，二进制是00000010，取反得到11111101，再加1得到11111110，这正好是-2的补码形式。
- 一个负数-2，补码是11111110，取反得到00000001，再加1得到00000010，这正好是2的二进制。

有一个例外是-128，因为正数的最大值是127，所以-128取反再加1得到的还是自己: 10000000，取反得到01111111，加1得到10000000

有了这两个特性，就可以通过上面的加法器实现减法：

```go
// BitNot 位取反，因为Bit不是真正的1位，不能简单地用^取反
func BitNot(a Bit) Bit {
    if (a == 1) {
        return 0
    } else {
        return 1
    }
}

// Bit8Subtractor 8位减法器，返回结果，和是否溢出
func Bit8Subtractor(a Bit8, b Bit8) (Bit8, Bit) {
    // 对b取反
    b[0] = BitNot(b[0])
    b[1] = BitNot(b[1])
    b[2] = BitNot(b[2])
    b[3] = BitNot(b[3])
    b[4] = BitNot(b[4])
    b[5] = BitNot(b[5])
    b[6] = BitNot(b[6])
    b[7] = BitNot(b[7])
    // 这里的进位为1，相当于加1
    return Bit8FullAdder(a, b, 1)
}
```

原理是：a - b 转换为 a + (-b)，我们对b取反，再加1，就得到了-b，现在写一个辅助函数测试一下：

```go
func sub(a int8, b int8) int8 {
    var a8, b8 Bit8;
    for i := 0; i < 8; i++ {
        a8[i] = Bit((a >> i) & 1)
        b8[i] = Bit((b >> i) & 1)
    }

    s8, _ := Bit8Subtractor(a8, b8)

    var s int8 = 0;
    for i := 0; i < 8; i++ {
        s |= int8(s8[i] << i)
    }
    return s
}

func main() {
    d := sub(21, -36)
    fmt.Printf("%d\n", d)  // 57
    d = sub(21, 127)
    fmt.Printf("%d\n", d)  // -106
}
```

恭喜，你又实现了一个减法器。

## 结尾

通过上面的讲解，也许会让我们更深入的理解计算机表达数字的方式，作为结束，最后写几个真正实用的函数，计算整型的最大值和最小值：

```go
func MinUint32() uint32 {
    return 0
}

func MaxUInt32() uint32 {
    return ^MinUint32()  // ^表示取反，和C不一样
}

func MaxInt32() int32 {
    return int32(MaxUInt32() >> 1)
}

func MinInt32() int32 {
    return ^MaxInt32()
}
```

能看明白背后的原理吗？