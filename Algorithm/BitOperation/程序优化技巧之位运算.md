<h1 align="center">程序优化技巧之位运算</h1>

[toc]

整型数值的位运算有很多奇技淫巧，有些技巧甚至经常拿来做面试题。但我觉得没有必要去理解那些很难的技巧，对于位运算，只需要掌握一些常见的用法就可以了，而这些用法通常也是很容易理解的。

## 标志位

最常见的用法是标志位，一个字节有8个位，可以用来表示8种可叠加的状态，比如

```c
#define FLAG1 0x0001
#define FLAG2 0x0002
#define FLAG3 0x0004
#define FLAG4 0x0008
```

- 用 **或** 增加一个标志位：

```c
flags |= FLAG1  // 增加标志
```

- 用**与非**清除一个标志位：

```c
flags &= ~FLAG2   // 清楚标志位
```

- 用**与**判断一个变量是否含有标志位：

```c
(flags & FLAG3) != 0  // 含有
```

## 2的幂运算

- 对一个数乘以2的幂，可以优化成左移操作：

```c
num << 1    // num * 2
num << 2    // num * 4
num << 3    // num * 8
```

- 同理对一个数整除以2的幂，可以优化成右移操作：

```c
num >> 1    // num / 2
num >> 2    // num / 4
num >> 3    // num / 8
```

- A对B取模，如果B是2的幂，可以优化成与的操作：

```c
A & (B -1)
```

比如B=2，对B取模等于：A & 1，这个特殊用例可以用来判断奇偶数，比如A & 1 == 0 表示偶数。

- 判断一个正整数是否是2的幂

```c
n && (!(n & (n - 1)))
```

一个数如果是2的幂，那么它的二进制只有1个1，比如10, 100, 1000，这个数减1是01, 011, 0111，这样相与必然等于0，这就是!(n & (n -1))的判断，有一个例外情况是0，0不是2的幂，但它和任意数与都为0，所以应该将它排除在外，所以最终的判断就是上面公式。

- 将A向上取整为B的倍数，如果B是2的幂，可以优化为下面的公式：

```c
(A + B - 1) & ~(B - 1)
```

比如向上取整为4的倍数，可以写成：`(A + 3) & ~3`，如果写成`A & ~3`那就变成向下取整为4的倍数。

- 将A向上取整为2的幂，假如A是32位正整数，公式是：

```c
v--;
v |= v >> 1;
v |= v >> 2;
v |= v >> 4;
v |= v >> 8;
v |= v >> 16;
v++;
```

## 异或加密

异或加密是一个很简单且速度很快的算法，它利用了xor的这个特性：`A ^ B ^ B = A`，其中A是明文，B是密钥。

- 加密过程是：`A ^ B = C`，A和B异或后得到密文C。
- 解密过程是：`C ^ B = A`，密文C和B异或后得到明文A。

为什么这个等式能成立呢，因为异或的两个规律：

- 一个数和它自己异域的结果等于0，即N ^ N = 0
- 一个数和0异域的结果等于它自己，即N ^ 0 = N

现在我们来推导这个过程：

```text
A ^ B ^ B = A ^ (B ^ B) = A ^ 0 = A
```

## 位图操作

有时候程序要存储一个状态数组，每个状态只有0和1两个值，我们在实现的时候可以用位来表示状态，这样存储的空间大小比正常的布尔数组要减少8倍，这个数组有这样的操作：

- 取索引n的状态
- 设置索引n的状态

假设数组是这样的：`unsigned char bita[N]`，首先要计算出索引所在的字节，接着算出索引在这个字节的第几位

```c
i1 = n >> 3  // n / 8
i2 = n & 7   // n % 8

// 取状态
(bita[i1] >> i2) & 1
// 设状态
bita[i1] |= （1 << i2）
```

## 更多技巧

上面是程序常用的一些位运算技巧，如果你想探究更多难懂的技巧，请
[参看这里](https://link.zhihu.com/?target=http%3A//graphics.stanford.edu/~seander/bithacks.html)。
或者
[参看这里](Bit Twiddling Hacks.md)