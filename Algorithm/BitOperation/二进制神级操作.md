<h1 align="center">二进制神级操作</h1>

[toc]

## 小技巧

- 将数字 A 的第 k 位设置为1：`A = A | (1 << (k - 1))`

- 将数字 A 的第 k 位设置为0：`A = A & ~(1 << (k - 1))`

- 检测数字 A 的第 k 位：`A & (1 << (k - 1)) != 0`

- Extract the lowest set bit 获取数字 A 的最低位：

  ```
  A & -A
  ```

   或者 

  ```
  A & ~(A - 1)
  ```

  - 例如数字 6（110）的最低位对应 2（10）

- 得到 111111..111: `~0`

## 利用或操作 `|` 和空格将英文字符转换为小写

```
('a' | ' ') = 'a'
('A' | ' ') = 'a'
```

## 利用与操作 `&` 和下划线将英文字符转换为大写

```
('b' & '_') = 'B'
('B' & '_') = 'B'
```

## 利用异或操作 `^` 和空格进行英文字符大小写互换

```
('d' ^ ' ') = 'D'
('D' ^ ' ') = 'd'
```

以上操作能够产生奇特效果的原因在于 ASCII 编码。字符其实就是数字，恰巧这些字符对应的数字通过位运算就能得到正确的结果，有兴趣的读者可以查 ASCII 码表自己算算，本文就不展开讲了。

## 获得int型最大值

```
int getMaxInt(){
        return (1 << 31) - 1;//2147483647， 由于优先级关系，括号不可省略
}
```

另一种写法

```
int getMaxInt(){
    return ~(1 << 31);//2147483647
}
```

C语言中不知道int占几个字节时候

```
int getMaxInt(){
    return ((unsigned int) - 1) >> 1;//2147483647
}
```



## 获得int型最小值

```
// 第一种
int getMinInt(){
    return 1 << 31; // -2147483648
}

// 第二种
int getMinInt(){ // 有些编译器不适用
    return 1 << -1;//-2147483648
}
```

## 获得long类型的最大值

//C语言

```c
long getMaxLong(){
    return ((unsigned long) - 1) >> 1;//2147483647
}
```

```java
long getMaxLong(){
    return ((long)1 << 127) - 1;//9223372036854775807
}
```

## 乘以2运算

```
int mulTwo(int n){//计算n*2 
    return n << 1;  
}
```

## 除以2运算

```
int divTwo(int n){//负奇数的运算不可用
    return n >> 1;//除以2
}
```

## 乘以2的m次方

```
int mulTwoPower(int n,int m){//计算n*(2^m)
    return n << m;
}
```

## 除以2的m次方

```
int divTwoPower(int n,int m){//计算n/(2^m)
    return n >> m;
```

## 计算2的n次方

```
int getFactorialofTwo(int n){//n > 0
    return 2 << (n-1); // 2的n次方
}
或

int getFactorialofTwo(int n) {
	return 1 << n; // 2的n次方
}
```

## 取两个数的最大值（某些机器上，效率比a>b ? a:b高）

通用版

```
int max(int a,int b){
    return b & ((a-b) >> 31) | a & (~(a-b) >> 31);
    /*如果a>=b,(a-b)>>31为0，否则为-1*/
}
```

C语言版

```c
int max(int x,int y){
    return x ^ ((x ^ y) & -(x < y));
    /* 如果x<y x<y返回1，否则返回0， 
	与0做与运算结果为0，与-1做与运算结果不变 */
}
```

## 取两个数的最小值（某些机器上，效率比a>b ? b:a高）

通用版

```
int min(int a,int b){
    return a & ((a-b) >> 31) | b & (~(a-b) >> 31);
    /*如果a>=b,(a-b)>>31为0，否则为-1*/
}
```

C语言版

```c
int min(int x,int y){
    return y ^ ((x ^ y) & -(x < y));
         /*如果x<y x<y返回1，否则返回0， 
            与0做与运算结果为0，与-1做与运算结果不变*/
}
```

## 判断两个数是否异号

```
int x = -1, y = 2;
bool f = ((x ^ y) < 0); // true

int x = 3, y = 2;
bool f = ((x ^ y) < 0); // false
```

这个技巧还是很实用的，利用的是补码编码的符号位。如果不用位运算来判断是否异号，需要使用 if else 分支，还挺麻烦的。读者可能想利用乘积或者商来判断两个数是否异号，但是这种处理方式可能造成溢出，从而出现错误。

## 不用临时变量交换两个数

```c
//普通操作
void swap(int &a, int &b) {
  a = a + b;
  b = a - b;
  a = a - b;
}

//位与操作
void swap(int &a, int &b) {
  a ^= b;
  b ^= a;
  a ^= b;
}
```

位与操作解释：第一步：a ^= b ---> a = (a^b);

第二步：b ^= a ---> b = b^(a^b) ---> b = (b^b)^a = a

第三步：a ^= b ---> a = (a^b)^a = (a^a)^b = b

## 位操作判断奇偶数

只要根据数的最后一位是 0 还是 1 来决定即可，为 0 就是偶数，为 1 就是奇数。

```text
if(0 == (a & 1)) {
 //偶数
}
```

## 位操作交换符号

- 交换符号将正数变成负数，负数变成正数

```text
int reversal(int a) {
  return ~a + 1;
}
```

整数取反加1，正好变成其对应的负数(补码表示)；负数取反加一，则变为其原码，即正数

## 位操作求绝对值

- 整数的绝对值是其本身，负数的绝对值正好可以对其进行取反加一求得，即我们首先判断其符号位（整数右移 31 位得到 0，负数右移 31 位得到 -1,即 0xffffffff），然后根据符号进行相应的操作

```text
int abs(int a) {
  int i = a >> 31;
  return i == 0 ? a : (~a + 1);
}
```

上面的操作可以进行优化，可以将 i == 0 的条件判断语句去掉。我们都知道符号位 i 只有两种情况，即 i = 0 为正，i = -1 为负。对于任何数与 0 异或都会保持不变，与 -1 即 0xffffffff 进行异或就相当于对此数进行取反,因此可以将上面三目元算符转换为((a^i)-i)，即整数时 a 与 0 异或得到本身，再减去 0，负数时与 0xffffffff 异或将 a 进行取反，然后在加上 1，即减去 i(i =-1)

```text
int abs2(int a) {
  int i = a >> 31;
  return ((a^i) - i);
}
```

## 位操作进行高低位交换

- 给定一个 16 位的无符号整数，将其高 8 位与低 8 位进行交换，求出交换后的值，如：

```text
34520的二进制表示：
10000110 11011000

将其高8位与低8位进行交换，得到一个新的二进制数：
11011000 10000110
其十进制为55430
```

从上面移位操作我们可以知道，只要将无符号数 a>>8 即可得到其高 8 位移到低 8 位，高位补 0；将 a<<8 即可将 低 8 位移到高 8 位，低 8 位补 0，然后将 a>>8 和 a<<8 进行或操作既可求得交换后的结果。

```text
unsigned short a = 34520;
a = (a >> 8) | (a << 8);
```

## 位操作进行二进制逆序

将无符号数的二进制表示进行逆序，求取逆序后的结果，如

```text
数34520的二进制表示：
10000110 11011000

逆序后则为：
00011011 01100001
它的十进制为7009
```

在字符串逆序过程中，可以从字符串的首尾开始，依次交换两端的数据。在二进制中使用位的高低位交换会更方便进行处理，这里我们分组进行多步处理。

- 第一步:以每 2 位为一组，组内进行高低位交换

```text
交换前： 10 00 01 10 11 01 10 00
交换后： 01 00 10 01 11 10 01 00
```

- 第二步：在上面的基础上，以每 4 位为 1 组，组内高低位进行交换

```text
交换前： 0100 1001 1110 0100
交换后： 0001 0110 1011 0001
```

- 第三步：以每 8 位为一组，组内高低位进行交换

```text
交换前： 00010110 10110001
交换后： 01100001 00011011
```

- 第四步：以每16位为一组，组内高低位进行交换

```text
交换前： 0110000100011011
交换后： 0001101101100001
```

对于上面的第一步，依次以 2 位作为一组，再进行组内高低位交换，这样处理起来比较繁琐，下面介绍另外一种方法进行处理。先分别取原数 10000110 11011000 的奇数位和偶数位，将空余位用 0 填充：

```text
原数：  10000110 11011000
奇数位： 10000010 10001000
偶数位： 00000100 01010000
```

再将奇数位右移一位，偶数位左移一位，此时将两个数据相或即可以达到奇偶位上数据交换的效果：

```text
原数：  10000110 11011000
奇数位右移一位： 0 10000010 1000100
偶数位左移一位：0000100 01010000 0
两数相或得到： 01001001 11100100
```

上面的方法用位操作可以表示为：

- 取a的奇数位并用 0 进行填充可以表示为：a & 0xAAAA
- 取a的偶数为并用 0 进行填充可以表示为：a & 0x5555 因此，上面的第一步可以表示为：
  a = ((a & 0xAAAA) >> 1) | ((a & 0x5555) << 1)
  同理，可以得到其第二、三和四步为：
  a = ((a & 0xCCCC) >> 2) | ((a & 0x3333) << 2)
  a = ((a & 0xF0F0) >> 4) | ((a & 0x0F0F) << 4)
  a = ((a & 0xFF00) >> 8) | ((a & 0x00FF) << 8)
  因此整个操作为：

```text
unsigned short a = 34520;

a = ((a & 0xAAAA) >> 1) | ((a & 0x5555) << 1);
a = ((a & 0xCCCC) >> 2) | ((a & 0x3333) << 2);
a = ((a & 0xF0F0) >> 4) | ((a & 0x0F0F) << 4);
a = ((a & 0xFF00) >> 8) | ((a & 0x00FF) << 8);
```

## 位操作统计二进制中 1 的个数

统计二进制1的个数可以分别获取每个二进制位数，然后再统计其1的个数，此方法效率比较低。这里介绍另外一种高效的方法，同样以 34520 为例，我们计算其 a &= (a-1)的结果：

- 第一次：计算前：1000 0110 1101 1000 计算后：1000 0110 1101 0000
- 第二次：计算前：1000 0110 1101 0000 计算后：1000 0110 1100 0000
- 第二次：计算前：1000 0110 1100 0000 计算后：1000 0110 1000 0000 我们发现，没计算一次二进制中就少了一个 1，则我们可以通过下面方法去统计：

```text
count = 0  
while(a){  
  a = a & (a - 1);  
  count++;  
}  
```

## 加一

```
int n = 1;
n = -~n;
// 现在 n = 2
```

## 减一

```
int n = 2;
n = ~-n;
// 现在 n = 1
```

PS：上面这三个操作就纯属装逼用的，没啥实际用处，大家了解了解乐呵一下就行。

## `n&(n-1)` 这个操作是算法中常见的，作用是消除数字 `n` 的二进制表示中的最后一个 1。

看个图就很容易理解了：

![img](media/1.png)

其核心逻辑就是，`n - 1` 一定可以消除最后一个 1，同时把其后的 0 都变成 1，这样再和 `n` 做一次 `&` 运算，就可以仅仅把最后一个 1 变成 0 了。

## 计算汉明权重（Hamming Weight）

![title](media/title.png)

就是让你返回 n 的二进制表示中有几个 1。因为 n & (n - 1) 可以消除最后一个 1，所以可以用一个循环不停地消除 1 同时计数，直到 n 变成 0 为止。

```
int hammingWeight(uint32_t n) {
    int res = 0;
    while (n != 0) {
        n = n & (n - 1);
        res++;
    }
    return res;
}
```

## 判断一个数是不是 2 的指数

一个数如果是 2 的指数，那么它的二进制表示一定只含有一个 1：

```
2^0 = 1 = 0b0001
2^1 = 2 = 0b0010
2^2 = 4 = 0b0100
```

如果使用 `n&(n-1)` 的技巧就很简单了（注意运算符优先级，括号不可以省略）：

```
bool isPowerOfTwo(int n) {
    if (n <= 0) return false;
    return (n & (n - 1)) == 0;
}
```

## 查找只出现一次的元素

这里就可以运用异或运算的性质：

一个数和它本身做异或运算结果为 0，即 `a ^ a = 0`；一个数和 0 做异或运算的结果为它本身，即 `a ^ 0 = a`。

对于这道题目，我们只要把所有数字进行异或，成对儿的数字就会变成 0，落单的数字和 0 做异或还是它本身，所以最后异或的结果就是只出现一次的元素：

```
int singleNumber(vector<int>& nums) {
    int res = 0;
    for (int n : nums) {
        res ^= n;
    }
    return res;
}
```

以上便是一些有趣/常用的位操作。其实位操作的技巧很多，有一个叫做 Bit Twiddling Hacks 的外国网站收集了几乎所有位操作的黑科技玩法，感兴趣的读者可以查看：

## 判断一个数是不是2的幂

```
bool isFactorialofTwo(int n){
    return n > 0 ? (n & (n - 1)) == 0 : false;
    /*如果是2的幂，n一定是100... n-1就是1111.... 
       所以做与运算结果为0*/
}
```

16.对2的n次方取余

```
int quyu(int m,int n){//n为2的次方
    return m & (n - 1);
    /*如果是2的幂，n一定是100... n-1就是1111.... 
     所以做与运算结果保留m在n范围的非0的位*/
}
```

## 求两个整数的平均值

```
int getAverage(int x, int y){
        return (x + y) >> 1;
}
```

另一种写法

```
int getAverage(int x, int y){
        return ((x ^ y) >> 1) + (x & y); 
     /*(x^y) >> 1得到x，y其中一个为1的位并除以2， 
       x&y得到x，y都为1的部分，加一起就是平均数了*/
}
```

## 从低位到高位，取n的第m位

```
int getBit(int n, int m){
    return (n >> (m-1)) & 1;
}
```

## 从低位到高位，将n的第m位置1

```
int setBitToOne(int n, int m){
    return n | (1 << (m-1));
    /*将1左移m-1位找到第m位，得到000...1...000 
      n在和这个数做或运算*/
}
```

## 从低位到高位，将n的第m位置0

```
int setBitToZero(int n, int m){
    return n & ~(1 << (m-1));
    /* 将1左移m-1位找到第m位，取反后变成111...0...1111 
       n再和这个数做与运算*/
}
```

## 取相反数

```
~n + 1;
//或
 ~(n - 1)
//或
(n ^ -1) + 1;
```

## 取整数n的二进制中最后一个1

```
// 写法一：
-n&n 
// 写法二：
(~n+1)&n
// 写法三：
~(n - 1)&n
```

## 去掉整数n的二进制中最后一个1

如：n = 010100, n -1 = 010011, n&(n - 1) = 010000。

```
n & (n - 1)
```


另附一些对程序效率上没有实质提高的位运算技巧，一些也是位运算的常识（面试也许会遇到）

## 计算n+1

```
-~n
```

## 计算n-1

```
~-n
```

## if(x == a) x = b; if(x == b) x = a;

```
x = a ^ b ^ x;
```

## sign函数，参数为n，当n>0时候返回1，n<0时返回-1，n=0时返回0

```
return !!n - (((unsigned)n >> 31) << 1);
```



## 参考

[fucking-algorithm/常用的位操作.md at master · labuladong/fucking-algorithm (github.com)](https://github.com/labuladong/fucking-algorithm/blob/master/算法思维系列/常用的位操作.md)

[Bit Manipulation 位运算常见套路及相应LeetCode算法题 - 简书 (jianshu.com)](https://www.jianshu.com/p/b93ba9e24f97)

[位运算的一些实用技巧 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/79754598)

[二进制加，减法,23个位运算技巧_技术空间站的博客-CSDN博客](https://blog.csdn.net/Mr_Quinn/article/details/89046983)