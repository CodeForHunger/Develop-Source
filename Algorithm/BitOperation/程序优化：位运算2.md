<h1 align="center">程序优化：位运算2</h1>

很早之前写过一篇[程序优化技巧之位运算](https://zhuanlan.zhihu.com/p/75589426)，例举了常用的位运算方法，在性能敏感的程序中，这些方法可以提高效率。

处理器很喜欢位运算，它能以最高效的方式执行；人类就不怎么喜欢了，因为这些代码很难读，比如我们看到这个公式：`12 / 4 = 3`一下子就能明白，但看到这个公式：`12 >> 2 = 3`就没那么好懂，需要在思维层面进行一些转换才能理解。

这一篇举两个例子，并试图解析它们的内在原理。

## 第一个例子是：计算整数的二进制1的个数。

比如1101，二进制1的个数是3，计算代码如下：

```c
int bitcount(uint32_t v) {
    int c = 0;
    while (v) {
        v &= v - 1;
        ++c;
    }
    return c;
}
```

核心代码是`v &= v - 1`，它的作用是将最低位的那个1清0，如何做到呢？用二进制的方式来思考，假设v不为0，我们只关心v中最低位的那个1，其他位不管它，那么v的二进制可以这样表示：

```text
xx..x 1 0..0
```

1前面的x表示任意值(0或1)，1后面肯定是0(因为都说了关注最低位的1)；v-1就可以表示成：

```text
xx..x 0 0..0
```

现在v & (v - 1) ：

```text
xx..x 1 0..0
    与
xx..x 0 0..0
------------------
xx..x 0 0..0
```

这样就把这个1给消除掉了，如此循环，直到v为0，循环多少次，就表明v有多少个二进制1。这个算法的消耗与1的个数有关，如果v的二进制全是1，那就要循环32次，如果是64位的数字，就要循环64次。

有没有更快的方法？有的，留到最后再说吧。

## 第2个例子是：将一个数向上取整为2的幂

比如3取整后是4，5取整后是8，8取整后还是8。一个优化后的算法是这样的：

```c
uint32_t next_pow2(uint32_t v) {
    --v;
    v |= v >> 1;
    v |= v >> 2;
    v |= v >> 4;
    v |= v >> 8;
    v |= v >> 16;
    return ++v;
}
```

初看有点头大，仔细一想还是能想明白的，如果v大于0，我们就关注最高位的1，v可以表示成：

```text
1xxxxxxx
```

v >> 1就是：

```text
01xxxxxx
```

`v = v | (v >> 1)`就是：

```text
1xxxxxxx
   或
01xxxxxx
-----------------
11xxxxxx
```

接着`v = v | (v >> 2)`就是：

```text
11xxxxxx
   或
0011xxxx
-----------------
1111xxxx
```

接着`v = v | (v >> 4`)就是：

```text
1111xxxx
   或
00001111
-----------------
11111111
```

这样一直运算就把最高位后面的BIT全部变成1，右移到16可以处理32位的整型，右移到32可以处理64的整型，最后v+1，就得到一个2的幂的值，这个值就是我们要的答案。

函数最前面之所以要--v，是为了处理v本身就是2的幂这种情况，如果不减，得到的值将是下一个2的幂。

## 更快的计算整数的二进制1的个数

第1个例子的程序效率与1的个数相关，下面这个与1的个数无关：

```c
uint32_t bitcount2(uint32_t v) {
    v = v - ((v >> 1) & 0x55555555);
    v = (v & 0x33333333) + ((v >> 2) & 0x33333333);
    v = (v + (v >> 4)) & 0x0F0F0F0F;
    v = v + (v >> 8);
    v = v + (v >> 16);
    return v & 0x0000003F;
}
```

当时看到这个程序有点震惊，这真的太硬核了，如果没有一个完整的推导过程，无论如何也想不出是怎么做到的。

它的算法这样的：

- v是32位整数，将v分成16等份，这样每份占2位，比如：

```text
10111001001110110001100110000100
分成16等分后：
10 11 10 01 00 11 10 11 00 01 10 01 10 00 01 00
```

- 计算出每部分的1的个数，由于每部分只有2位，所以每部分的计算方法是(假设值是xx)：

```text
每部分1的个数 = (xx & 01) + ((xx >> 1) & 01)
```

将所有部分合起来运算就是：

```text
(xxxx..xx & 0101..01) + ((xxxx..xx >> 1) & 0101..01)
```

现在变成C的语法就是：

```c
// 0x55555555的二进制就是010101..01
v = (v & 0x55555555) + ((v >> 1) & 0x55555555);
```

运算之后v变成这样：

```text
10 11 10 01 00 11 10 11 00 01 10 01 10 00 01 00
                    ↓
01 10 01 01 00 10 01 10 00 01 01 01 01 00 01 00
```

也就是每部分变成1的个数，比如原始值第2部分是11，有两个1，运算后二进制就变成10。

- 后面的计算就是一步步地将每部分的值加起来。
- 首先，第1部分+第2部分，第3部分+第3部分，...第15部分+第16部分：

```c
// 0x33333333的二进制是0011..0011
v = (v & 0x33333333) + ((v >> 2) & 0x33333333);
```

运算之后v的值变成：

```text
01 10 01 01 00 10 01 10 00 01 01 01 01 00 01 00
                    ↓
0011  0010  0010  0011  0001  0010  0001  0001
```

- 现在V变成8等份，每份占4位，接着计算第1部分+第2部分...第7部分+第8部分：

```c
// 0x0F0F0F0F的二进制是00001111...00001111
v = (v & 0x0F0F0F0F) + ((v >> 4) & 0x0F0F0F0F);
```

运算之后v的值变成

```text
0011  0010  0010  0011  0001  0010  0001  0001 
                    ↓
0000‭0101‬    0000‭0101‬    00000011    00000010
```

- 现在v变成4等份，每份占8位，继续相加：

```c
// 0x00FF00FF的二进制是0000000011111111 0000000011111111
v = (v & 0x00FF00FF) + ((v >> 8) & 0x00FF00FF);
```

运算之后v的值变成

```text
0000‭0101‬    0000‭0101‬    00000011    00000010
                    ↓
00000000000‭1010        ‬000000000000‭0101‬
```

- 现在v变成2等分了，最后一次相加：

```c
// 0x0000FFFF的二进制是0000000000000000 1111111111111111
v = (v & 0x0000FFFF) + ((v >> 16) & 0x0000FFFF);
```

运算之后v的值变成

```text
00000000000‭1010        ‬000000000000‭0101‬
                    ↓
    ‭00000000000000000000000000001111‬
```

- 看看最后这个值，十进制是15，正好等于原始值`10111001001110110001100110000100`的1的个数。

整个运算过程很完美地体现了`分而治之`的编程思想，把上面代码整合起来就是：

```c
uint32_t bitcount2(uint32_t v) {
    v = (v & 0x55555555) + ((v >> 1) & 0x55555555);
    v = (v & 0x33333333) + ((v >> 2) & 0x33333333);
    v = (v & 0x0F0F0F0F) + ((v >> 4) & 0x0F0F0F0F);
    v = (v & 0x00FF00FF) + ((v >> 8) & 0x00FF00FF);
    v = (v & 0x0000FFFF) + ((v >> 16) & 0x0000FFFF);
    return v;
}
```

对代码进一步精减，最终就变成上面那个样子，至于怎么精减，还是留给你们思考一下吧，本文到此结束。